// Systemd integration for systemd-swap
// SPDX-License-Identifier: GPL-3.0-or-later

use std::ffi::CString;
use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::Path;
use std::process::{Command, Stdio};

use thiserror::Error;

use crate::config::RUN_SYSD;
use crate::helpers::{makedirs, relative_symlink, write_file};
use crate::info;

#[derive(Error, Debug)]
pub enum SystemdError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Helper error: {0}")]
    Helper(#[from] crate::helpers::HelperError),
    #[error("Systemd notify failed")]
    NotifyFailed,
    #[error("Command failed: {0}")]
    CommandFailed(String),
}

pub type Result<T> = std::result::Result<T, SystemdError>;

/// Notify systemd that we're ready
pub fn notify_ready() {
    let _ = libsystemd::daemon::notify(false, &[libsystemd::daemon::NotifyState::Ready]);
}

/// Notify systemd that we're stopping
pub fn notify_stopping() {
    let _ = libsystemd::daemon::notify(false, &[libsystemd::daemon::NotifyState::Stopping]);
}

/// Notify status message
pub fn notify_status(status: &str) {
    let _ = libsystemd::daemon::notify(false, &[(libsystemd::daemon::NotifyState::Status(status.to_string()))]);
}

/// Run systemctl command
pub fn systemctl(action: &str, unit: &str) -> Result<()> {
    let args: Vec<&str> = if action == "daemon-reload" {
        vec!["systemctl", "daemon-reload"]
    } else {
        vec!["systemctl", action, unit]
    };

    let status = Command::new(args[0])
        .args(&args[1..])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()?;

    if status.success() {
        Ok(())
    } else {
        Err(SystemdError::CommandFailed(format!(
            "systemctl {} {} failed with {}",
            action, unit, status
        )))
    }
}

/// Device type for swap unit
#[derive(Debug, Clone, Copy)]
pub enum DeviceType {
    File,
    Block,
}

impl std::fmt::Display for DeviceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DeviceType::File => write!(f, "File"),
            DeviceType::Block => write!(f, "Block/Partition"),
        }
    }
}

/// Generate a swap unit file
pub fn gen_swap_unit(
    what: &Path,
    priority: Option<i32>,
    options: Option<&str>,
    tag: &str,
) -> Result<String> {
    let what = fs::canonicalize(what)?;
    let what_str = what.to_string_lossy();

    // Determine device type
    let metadata = fs::metadata(&what)?;
    let device_type = if metadata.permissions().mode() & 0o170000 == 0o060000 {
        // Block device
        if what_str.contains("loop") {
            DeviceType::File
        } else {
            DeviceType::Block
        }
    } else {
        DeviceType::File
    };

    // Get unit name using systemd-escape
    let unit_name = Command::new("systemd-escape")
        .args(["-p", "--suffix=swap", &what_str])
        .stdout(Stdio::piped())
        .output()
        .map(|o| String::from_utf8_lossy(&o.stdout).trim().to_string())?;

    let unit_path = format!("{}/system/{}", RUN_SYSD, unit_name);

    // Build unit content
    let mut content = format!(
        r#"[Unit]
Description=Swap {}
Documentation=https://github.com/Nefelim4ag/systemd-swap

# Generated by systemd-swap
# Tag={}

[Swap]
What={}
TimeoutSec=1h
"#,
        device_type, tag, what_str
    );

    if let Some(prio) = priority {
        content.push_str(&format!("Priority={}\n", prio));
    }

    if let Some(opts) = options {
        content.push_str(&format!("Options={}\n", opts));
    }

    write_file(&unit_path, &content)?;

    // Create symlinks
    let wants_dir = format!("{}/system/swap.target.wants", RUN_SYSD);
    makedirs(&wants_dir)?;
    relative_symlink(&unit_path, format!("{}/{}", wants_dir, unit_name))?;

    if matches!(device_type, DeviceType::File) {
        let local_fs_dir = format!("{}/system/local-fs.target.wants", RUN_SYSD);
        makedirs(&local_fs_dir)?;
        relative_symlink(&unit_path, format!("{}/{}", local_fs_dir, unit_name))?;
    }

    info!("Generated swap unit: {}", unit_name);
    Ok(unit_name)
}

/// Disable a swap device using the swapoff(2) syscall directly
pub fn swapoff(device: &str) -> Result<()> {
    let c_path = CString::new(device).map_err(|_| {
        SystemdError::CommandFailed(format!("invalid path for swapoff: {}", device))
    })?;
    let ret = unsafe { libc::swapoff(c_path.as_ptr()) };
    if ret == 0 {
        Ok(())
    } else {
        let err = std::io::Error::last_os_error();
        Err(SystemdError::CommandFailed(format!(
            "swapoff {} failed: {}",
            device, err
        )))
    }
}
